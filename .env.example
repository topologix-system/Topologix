# Topologix Environment Configuration Template
#
# USAGE:
# Quick Start:
#   - Development: cp .env.development .env
#   - Production:  cp .env.production .env
#
# Or use docker-compose --env-file option:
#   - Development: docker compose --env-file .env.development up -d
#   - Production:  docker compose --env-file .env.production up -d
#
# Then start the containers:
#   docker compose up -d

# ============================================
# Backend Configuration
# ============================================

# Backend Command (Environment-specific)
# Development (Flask dev server with hot reload):
#   BACKEND_COMMAND=python app.py
# Production (Gunicorn WSGI server):
#   BACKEND_COMMAND=gunicorn --bind 0.0.0.0:5000 --workers 4 --threads 2 --timeout 120 --access-logfile - --error-logfile - --log-level info 'app:app'

# Flask Environment
FLASK_ENV=development
FLASK_DEBUG=True

# Batfish Service
BATFISH_HOST=batfish
BATFISH_PORT=9996

# CORS Origins (comma-separated)
# Add your frontend URLs here. For production, replace with your actual domain
# Example: CORS_ORIGINS=http://localhost:3000,https://yourdomain.com
CORS_ORIGINS=http://localhost:3000

# ============================================
# Authentication (Optional Feature)
# ============================================

# Enable/Disable Authentication System
# Set to 'true' to enable JWT-based authentication
# Set to 'false' for open access (default for OSS distribution)
AUTH_ENABLED=false

# Allow User Self-Registration
# Set to 'true' to allow new users to register themselves
# Set to 'false' to restrict registration to admin-only (more secure for production)
# SECURITY WARNING: When enabled, anyone can create an account. Consider enabling
# email verification and implementing proper monitoring/moderation.
# Default: 'true' for easier OSS onboarding
ALLOW_REGISTRATION=true

# Default Admin Credentials (only used when AUTH_ENABLED=true)
# Leave AUTH_DEFAULT_ADMIN_PASS empty to trigger first-time setup wizard
AUTH_DEFAULT_ADMIN_USER=admin
AUTH_DEFAULT_ADMIN_PASS=

# JWT Secret Keys (auto-generated if not set, but should be set in production)
# Generate using: python3 -c "import secrets; print(secrets.token_urlsafe(32))"
# SECRET_KEY=
# JWT_SECRET_KEY=
# CSRF_SECRET_KEY=

# JWT Access Token Expiration (in seconds)
# OWASP ASVS L2: < 12 hours (1 hour is compliant)
# OWASP ASVS L3 (stricter): < 15 minutes
# Default: 3600 (1 hour) - Balance between security and user experience
# For high-security environments, consider: 900 (15 minutes)
JWT_ACCESS_TOKEN_EXPIRES=3600

# ============================================
# Login Security Configuration
# ============================================

# Maximum Failed Login Attempts Before Lockout
# Number of consecutive failed login attempts allowed before account lockout
# OWASP ASVS recommendation: 5-10 attempts
# Default: 5 attempts
# ACCOUNT_LOCKOUT_THRESHOLD=5

# Account Lockout Duration (in minutes)
# How long to lock the account after exceeding failed login threshold
# Default: 30 minutes
# LOGIN_LOCKOUT_DURATION_MINUTES=30

# NOTE: IP-based rate limiting is currently disabled
# Reason: This application may be deployed behind NAT/NAPT gateways, load balancers,
# or proxies where multiple users share the same IP address. IP-based blocking
# could incorrectly block legitimate users in these environments.
# Security is provided by account-based lockout (ACCOUNT_LOCKOUT_THRESHOLD).
#
# If you are certain your deployment has unique client IPs, you can implement
# IP-based blocking by modifying backend/security/auth.py (see line 433-446).

# Maximum Login History Records
# Number of login history records to keep per user
# Used for audit trails and security monitoring
# Default: 50 records
# LOGIN_HISTORY_MAX_RECORDS=50

# Maximum Failed Login Attempts Records
# Number of failed login attempt records to keep
# Used for security monitoring and attack detection
# Default: 100 records
# FAILED_LOGIN_ATTEMPTS_MAX_RECORDS=100

# Maximum Blocked IPs Records
# Number of blocked IP records to keep
# Used for security monitoring and attack pattern analysis
# Default: 200 records
# BLOCKED_IPS_MAX_RECORDS=200

# ============================================
# Email Configuration (for password reset, notifications, etc.)
# ============================================

# Email Provider: 'console' (print to console), 'smtp' (send via SMTP), 'disabled' (no email)
# Default: 'console' for development
EMAIL_PROVIDER=console

# Email From Address and Name
EMAIL_FROM=noreply@topologix.local
EMAIL_FROM_NAME=Topologix

# SMTP Configuration (only used when EMAIL_PROVIDER=smtp)
SMTP_HOST=localhost
SMTP_PORT=587
SMTP_USERNAME=
SMTP_PASSWORD=
SMTP_USE_TLS=true

# Password Reset Configuration
# Token expiry time in seconds (default: 3600 = 1 hour)
PASSWORD_RESET_TOKEN_EXPIRY=3600

# Frontend base URL for password reset links
# Update this to match your frontend URL
PASSWORD_RESET_URL_BASE=http://localhost:3000

# ============================================
# Database Configuration (only used when AUTH_ENABLED=true)
# ============================================

# Database URL - supports SQLite, PostgreSQL, MySQL
# SQLite (default - good for development and small deployments):
DATABASE_URL=sqlite:////app/data/topologix.db

# PostgreSQL (recommended for production):
# DATABASE_URL=postgresql://username:password@postgres:5432/topologix

# MySQL:
# DATABASE_URL=mysql+pymysql://username:password@mysql:3306/topologix

# Notes:
# - When AUTH_ENABLED=false, database is not initialized
# - For Docker, use /app/data/topologix.db for SQLite to persist in volume
# - For PostgreSQL/MySQL, add service to docker-compose.yaml

# ============================================
# Frontend Configuration
# ============================================

# API Base URL
# Backend API endpoint for frontend to connect to
# For production, replace with your actual backend URL
# Example: VITE_API_BASE_URL=https://api.yourdomain.com
VITE_API_BASE_URL=http://localhost:5000

# Authentication (must match backend AUTH_ENABLED)
VITE_AUTH_ENABLED=false

# Timezone for displaying dates (IANA timezone identifier)
# Default: Asia/Tokyo (JST, UTC+9)
# Examples: America/New_York, Europe/London, UTC
VITE_TIMEZONE=Asia/Tokyo

# ============================================
# Reverse Proxy Configuration
# ============================================

# Behind Reverse Proxy Flag
# Set to 'true' if Flask application is behind a reverse proxy (nginx, Caddy, etc.)
# Set to 'false' for direct connections (not recommended for production)
#
# CRITICAL SECURITY WARNING:
# - When 'true': Flask will trust X-Forwarded-For headers for IP extraction
# - When 'false': Flask will use direct connection IP (ignores proxy headers)
# - Setting 'true' without actual proxy: SECURITY VULNERABILITY (IP spoofing possible)
# - Setting 'false' with actual proxy: All IPs will appear as proxy IP
#
# This setting MUST match your actual infrastructure setup!
# Docker deployments with nginx: Set to 'true'
# Default: 'false' (safer default - prevents IP spoofing if misconfigured)
BEHIND_REVERSE_PROXY=false

# Number of trusted proxy layers between client and backend
# This setting is critical for proper IP address extraction in security logs
#
# SECURITY WARNING: Incorrect values can allow IP spoofing attacks!
#
# Common values:
#   0 = No proxy (direct connection - not recommended for production)
#   1 = Single proxy layer (nginx in Docker, typical setup) [DEFAULT]
#   2 = Two proxy layers (CDN/Caddy -> nginx -> Flask)
#   3+ = Multiple proxy layers (complex infrastructure)
#
# How to determine the correct value:
#   Count the number of proxies between the internet and your Flask application
#   Example: Internet -> Cloudflare (1) -> nginx (2) -> Flask = TRUSTED_PROXY_COUNT=2
#
# Default: 1 (single nginx proxy in Docker)
# TRUSTED_PROXY_COUNT=1

# ============================================
# Docker Configuration
# ============================================

# Docker Image Names
# Override these when deploying to custom registries or for forked repositories
# Useful for CI/CD pipelines and custom deployments
#
# Format: registry/namespace/image:tag
# Examples:
#   - GitHub Container Registry: ghcr.io/username/topologix/backend:latest
#   - Docker Hub: username/topologix-backend:v1.0.0
#   - Private Registry: registry.example.com/topologix/backend:latest
#
# Backend Docker Image
# Default: ghcr.io/topologix-system/topologix/backend:latest
# BACKEND_IMAGE=ghcr.io/topologix-system/topologix/backend:latest

# Frontend Docker Image
# Default: ghcr.io/topologix-system/topologix/frontend:latest
# FRONTEND_IMAGE=ghcr.io/topologix-system/topologix/frontend:latest

# ============================================
# Advanced Configuration
# ============================================

# Rate Limiting
# RATELIMIT_ENABLED=true
# RATELIMIT_DEFAULT_PER_MINUTE=60
# RATELIMIT_DEFAULT_PER_HOUR=600

# Redis (for production caching and session storage)
# REDIS_URL=redis://localhost:6379/0

# Logging
# LOG_LEVEL=INFO
# LOG_FILE=topologix.log
# AUDIT_LOG_FILE=topologix_audit.log

# File Upload
# MAX_CONTENT_LENGTH=10485760  # 10MB in bytes
# UPLOAD_FOLDER=/tmp/topologix_uploads

# Paths
# SNAPSHOTS_DIR=/snapshots

# Testing Configuration
# Enable Flask testing mode (disables error catching for better test debugging)
# WARNING: Never enable in production! Only use during automated testing.
# FLASK_TESTING=false

# Port Configuration
# Override the default port for backend service
# Default: 5000 (standard Flask port)
# Note: When using Docker, this is typically handled by docker-compose.yaml
# PORT=5000